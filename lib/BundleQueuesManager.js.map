{"version":3,"sources":["../src/lib/BundleQueuesManager.js"],"names":["generateAdapterForBundleQueuesManager","cursorsManager","memory","bundles","nextBundleIds","adapters","getCursor","cursorId","callback","cursors","getBundle","bundleId","bundle","get","setBundle","set","cursor","id","unsetBundle","getNextBundleId","nextBundleId","setNextBundleId","BundleQueuesManager","executeBundle","type","path","value","undefined","splice","start","deleteCount","items","Error"],"mappings":"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","file":"BundleQueuesManager.js","sourcesContent":["import lodash from 'lodash';\n\n/**\n * Method for generate example local storage for `bundles`, `nextBundleIds` and adapters for `BandleQueuesManager` `constructor`.\n * @param {CursorsManager} cursorsManager \n * @returns {Object}\n * @example\n * var cm = new CursorsManager(Cursor);\n * var memory = generateAdapterForBundleQueuesManager(cm);\n * var bqm = new BundleQueuesManage(...memory.adapters);\n * var c = cm.new('any',{'some':['things','and','others']});\n */\nfunction generateAdapterForBundleQueuesManager(cursorsManager) {\n  var memory = {\n    bundles: {},\n    nextBundleIds: {},\n    adapters: [\n      function getCursor(cursorId, callback) {\n        if (cursorsManager.cursors[cursorId])\n          callback(cursorsManager.cursors[cursorId]);\n      },\n      function getBundle(cursorId, bundleId, callback) {\n        var bundle = lodash.get(memory.bundles, [cursorId, bundleId]);\n        callback(bundle);\n      },\n      function setBundle(bundle) {\n        lodash.set(memory.bundles, [bundle.cursor, bundle.id], bundle);\n      },\n      function unsetBundle(bundle) {\n        if (memory.bundles[bundle.cursor]) {\n          delete memory.bundles[bundle.cursor][bundle.id];\n        }\n      },\n      function getNextBundleId(cursorId, callback) {\n        var nextBundleId = lodash.get(memory.nextBundleIds, [cursorId]);\n        if (typeof(nextBundleId) == 'number') {\n          callback(nextBundleId);\n        } else {\n          this.setNextBundleId(cursorId, 0);\n          callback(0);\n        }\n      },\n      function setNextBundleId(cursorId, nextBundleId) {\n        memory.nextBundleIds[cursorId] = nextBundleId;\n      }\n    ],\n  };\n\n  return memory;\n}\n\n/**\n * Queue of bundles execution for multiple cursors. You must descrobe adapter-methods for store bundles and queue informatation per each cursor. You can see example of adapters in `generateAdapterForBundleQueuesManager` function.\n * @class\n * @memberof module:ancient-cursor\n */\nclass BundleQueuesManager {\n  \n  /**\n   * @constructs BundleQueuesManager\n   * @param {BundleQueuesManager~getCursor} getCursor\n   * @param {BundleQueuesManager~getBundle} getBundle\n   * @param {BundleQueuesManager~setBundle} setBundle\n   * @param {BundleQueuesManager~unsetBundle} unsetBundle\n   * @param {BundleQueuesManager~getNextBundleId} getNextBundleId\n   * @param {BundleQueuesManager~setNextBundleId} setNextBundleId\n   */\n  constructor(\n    getCursor,\n    getBundle,\n    setBundle,\n    unsetBundle,\n    getNextBundleId,\n    setNextBundleId,\n  ) {\n    this.getCursor = getCursor;\n    this.getBundle = getBundle;\n    this.setBundle = setBundle;\n    this.unsetBundle = unsetBundle;\n    this.getNextBundleId = getNextBundleId;\n    this.setNextBundleId = setNextBundleId;\n  }\n  \n  /**\n   * Receive bundle object. If it bundle is next in queue, then execute it, else just save into storage within adapter methods.\n   * @param {Bundle} bundle\n   * @param {Function} callback - Calls after all executable bundles did executed, and next bundle not founded.\n   */\n  useBundle(bundle, callback) {\n    this.getNextBundleId(bundle.cursor, (nextBundleId) => {\n      if (bundle.id == nextBundleId) {\n        this.executeBundle(bundle, callback);\n      } else {\n        if (bundle.id > nextBundleId) {\n          this.setBundle(bundle);\n        }\n        if (callback) callback();\n      }\n    });\n  }\n  \n  /**\n   * Execute bundle without queue. Not for manual usage. After execution, try to execute next bandle in queue, if it exists.\n   * @param {Bundle} bundle\n   * @param {Function} callback - Calls after all executable bundles did executed, and next bundle not founded.\n   */\n  executeBundle(bundle, callback) {\n    this.getCursor(bundle.cursor, (cursor) => {\n      if (cursor) {\n        switch (bundle.type) {\n          case 'set':\n            cursor.set(bundle.path, bundle.value);\n            break;\n          case 'unset':\n            cursor.set(bundle.path, undefined);\n            break;\n          case 'splice':\n            cursor.splice(bundle.path, bundle.start, bundle.deleteCount, ...bundle.items);\n            break;\n          default:\n            throw new Error(`Bundle type \"${bundle.type}\" is unexpected.`);\n        }\n        this.unsetBundle(bundle);\n        this.setNextBundleId(bundle.cursor, bundle.id + 1);\n        this.getBundle(bundle.cursor, bundle.id + 1, (bundle) => {\n          if (bundle) this.executeBundle(bundle, callback);\n          else if (callback) callback();\n        });\n      } else if (callback) callback();\n    });\n  }\n}\n\nexport {\n  BundleQueuesManager,\n  generateAdapterForBundleQueuesManager,\n};\n\n/**\n * @callback BundleQueuesManager~getCursor\n * @memberof module:ancient-cursor\n * @param cursorId\n * @param {Function} callback - (cursor) => {}\n */\n\n/**\n * @callback BundleQueuesManager~getBundle\n * @memberof module:ancient-cursor\n * @param cursorId\n * @param bundleId\n * @param {Function} callback - (bundle) => {}\n */\n\n/**\n * @callback BundleQueuesManager~setBundle\n * @memberof module:ancient-cursor\n * @param {Bundle} bundle\n */\n\n/**\n * @callback BundleQueuesManager~unsetBundle\n * @memberof module:ancient-cursor\n * @param {Bundle} bundle\n */\n\n/**\n * @callback BundleQueuesManager~getNextBundleId\n * @memberof module:ancient-cursor\n * @param cursorId\n * @param {Function} callback - (nextBundleId) => {}\n */\n\n/**\n * @callback BundleQueuesManager~setNextBundleId\n * @memberof module:ancient-cursor\n * @param cursorId\n * @param nextBundleId\n */"]}
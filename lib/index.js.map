{"version":3,"sources":["../src/lib/index.js"],"names":["executeBundle","executeBundleSet","executeBundleUnset","executeBundleSplice","repl","require","lodash","EventEmitter","Cursor","query","data","manager","id","emitter","path","after","before","cloneDeep","set","emit","start","deleteCount","clone","get","isArray","Error","items","splice","handler","listener","beforeValue","isNull","afterValue","isEqual","stop","removeListener","on","BundlesQueue","nextId","handling","queue","task","handleNext","_handler","done","CursorsManager","cursors","cursor","bundle","executers","type","value","undefined","unset"],"mappings":"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","file":"index.js","sourcesContent":["var repl = require('repl');\nvar lodash = require('lodash');\nvar EventEmitter = require('events');\n\n/**\n * One query capsule.\n */\nexport class Cursor {\n  \n  /**\n   * @constructs Cursor\n   * @param query - Query resolves current cursor.\n   * @param data - Any data by resolved query.\n   */\n  constructor(query, data, manager, id) {\n    this.query = query;\n    this.data = data;\n    this.manager = manager;\n    this.id = id;\n    this.emitter = new EventEmitter();\n  }\n  \n  /**\n   * Way to change data changes in specified path.\n   * @param {string} path\n   * @param after\n   */\n  set(path, after) {\n    /**\n     * @todo Find better, economically then cloneDeep.\n     */\n    var before = lodash.cloneDeep(this.data);\n    if (!path) this.data = after;\n    else this.data = lodash.set(this.data || {}, path, after);\n    this.emitter.emit('changed', before, this.data);\n  }\n  \n  /**\n   * Way to change array data in specified path. Unlike the standard splice, all arguments are required, except items.\n   * @param {string} path\n   * @param {number} start\n   * @param {number} deleteCount\n   * @param {...*} [items]\n   */\n  splice(path, start, deleteCount, ...items) {\n    var data = lodash.clone(this.get(path));\n    if (!lodash.isArray(data)) throw new Error(`Data by path is not an array.`);\n    data.splice(start, deleteCount, ...items);\n    this.set(path, data);\n  }\n  \n  /**\n   * Getter from data. Handler can observe changes by current path in data.\n   * @param {string} path\n   * @param {Cursor~handler} [handler] - Notify you about changes in data by path.\n   * @return data - Returns someting from data by spcefied path.\n   */\n  get(path = null, handler) {\n    if (typeof(handler) == 'function') {\n      var listener = (before, after) => {\n        var beforeValue = lodash.isNull(path)?before:lodash.get(before, path);\n        var afterValue = lodash.isNull(path)?after:lodash.get(after, path);\n        if (!lodash.isEqual(beforeValue, afterValue)) {\n          handler(beforeValue, afterValue, stop, this);\n        }\n      };\n      var stop = () => this.emitter.removeListener('changed', listener);\n      this.emitter.on('changed', listener);\n    }\n    return lodash.isNull(path)?this.data:lodash.get(this.data, path);\n  }\n}\n\n/**\n * @callback Cursor~handler\n * @param before\n * @param after\n * @param {Function} stop\n * @param {Cursor} cursor\n */\n\n/**\n * Queue of bundles execution.\n * You must override _handler, for parse bandles for your cursors.\n */\nexport class BundlesQueue {\n  \n  /**\n   * @constructs BundlesQueue\n   */\n  constructor() {\n    this.nextId = 0;\n    this.handling = false;\n    this.queue = {};\n  }\n  \n  /**\n   * Add received bundles into queue.\n   * @param {number} id\n   * @param task - Any data for your _handler.\n   */\n  addBundle(id, task) {\n    this.queue[id] = task;\n    this.handleNext();\n  }\n  \n  /**\n   * Handle next possible bundle from queue.\n   * Do not do anything if there is no next mandatory bundle in queue.\n   * It is called automatically after each {@link BundlesQueue#addBundle}\n   */\n  handleNext() {\n    /**\n     * @todo May be need protect from call stack, as timeout 0 or some think as...\n     */\n    if (this.handling) return;\n    if (this.queue[this.nextId]) {\n      this.handling = true;\n      this._handler(this.nextId, this.queue[this.nextId], () => {\n        this.handling = false;\n        delete this.queue[this.nextId];\n        this.nextId++;\n        this.handleNext();\n      });\n    }\n  }\n  \n  /**\n   * You must overrided this method, which would somehow handle each bandle.\n   */\n  _handler(id, task, done) {\n    throw new Error('Method _handler must be overrided.');\n  }\n}\n\n/**\n * A small registrar of cursors. Sends into Cursor constructor unique id and link to current manager.\n */\nexport class CursorsManager {\n  constructor(Cursor = Cursor) {\n    this.Cursor = Cursor;\n    this.cursors = {};\n    this.nextId = 0;\n  }\n  \n  /**\n   * Constructs new {@link CursorsManager#Cursor}.\n   * @param query\n   * @param data\n   */\n  new(query, data) {\n    var cursor = new this.Cursor(query, data, this, this.nextId);\n    this.cursors[this.nextId] = cursor;\n    this.nextId++;\n    return cursor;\n  }\n}\n\n/**\n * Attention! If the executers object does not have the correct executer type, an error will be thrown.\n * @param {Object} bundle\n * @param {number} bundle.cursor - id of cursor on current client\n * @param {string} bundle.type - set, unset or splice string\n * @param {Object} executers\n * @param {parseBundle~parser} executers.* - executers for each possible bundle\n * @param {Cursor} cursor\n * @throws Uncaught TypeError: executers[bundle.type] is not a function\n */\nexport function executeBundle(bundle, cursor, executers) {\n  executers[bundle.type](bundle, cursor);\n}\n\n/**\n * @param {Object} bundle\n * @param {string} bundle.path\n * @param bundle.value\n * @param {Cursor} cursor\n */\nexport function executeBundleSet(bundle, cursor) {\n  cursor.set(bundle.path, bundle.value);\n}\n\n/**\n * @param {Object} bundle\n * @param {string} bundle.path\n * @param {Cursor} cursor\n */\nexport function executeBundleUnset(bundle, cursor) {\n  cursor.set(bundle.path, undefined);\n}\n\n/**\n * @param {Object} bundle\n * @param {string} bundle.path\n * @param {number} bundle.start\n * @param {number} bundle.deleteCount\n * @param {Array} bundle.items\n * @param {Cursor} cursor\n */\nexport function executeBundleSplice(bundle, cursor) {\n  cursor.splice(bundle.path, bundle.start, bundle.deleteCount, ...bundle.items);\n}\n\n/**\n * Default executers object.\n */\nexport var executers = {\n  set: executeBundleSet,\n  unset: executeBundleUnset,\n  splice: executeBundleSplice,\n};"]}
{"version":3,"sources":["../src/lib/index.js"],"names":["executeBundle","executeBundleSet","executeBundleUnset","executeBundleSplice","repl","require","lodash","EventEmitter","Cursor","query","data","manager","id","emitter","path","after","_path","toPath","beforeByPath","get","length","set","emit","before","action","toArray","arguments","start","deleteCount","items","clone","isArray","Error","splice","handler","on","isNull","eventPath","listener","changes","isClone","beforeValue","afterValue","eventPathLocal","slice","isEqual","stop","removeListener","BundlesQueue","nextId","handling","queue","task","handleNext","_handler","done","CursorsManager","cursors","cursor","bundle","executers","type","value","undefined","unset"],"mappings":"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","file":"index.js","sourcesContent":["var repl = require('repl');\nvar lodash = require('lodash');\nvar EventEmitter = require('events');\n\n/**\n * One query capsule.\n */\nexport class Cursor {\n  \n  /**\n   * @constructs Cursor\n   * @param query - Query resolves current cursor .We keep it just in case. Suddenly, to work with data, you need to compare them with the query?\n   * @param data - Any data by resolved query.\n   */\n  constructor(query, data, manager, id) {\n    this.query = query;\n    this.data = data;\n    this.manager = manager;\n    this.id = id;\n    this.emitter = new EventEmitter();\n  }\n  \n  /**\n   * Way to change data changes in specified path.\n   * @param {string|string[]} path\n   * @param after\n   */\n  set(path, after) {\n    var _path = lodash.toPath(path); \n    \n    var beforeByPath = lodash.get(this.data, _path);\n    \n    if (!_path.length) this.data = after;\n    else this.data = lodash.set(this.data || {}, _path, after);\n    \n    this.emitter.emit('changed', { before: beforeByPath, path: _path, action: 'set', 'arguments': lodash.toArray(arguments), });\n  }\n  \n  /**\n   * Way to change array data in specified path. Unlike the standard splice, all arguments are required, except items.\n   * @param {string|string[]} path\n   * @param {number} start\n   * @param {number} deleteCount\n   * @param {...*} [items]\n   */\n  splice(path, start, deleteCount, ...items) {\n    var _path = lodash.toPath(path); \n    \n    var beforeByPath = lodash.clone(lodash.get(this.data, _path));\n    \n    var data = this.get(_path);\n    \n    if (!lodash.isArray(data)) throw new Error(`Data by path is not an array.`);\n    \n    data.splice(start, deleteCount, ...items);\n    \n    this.emitter.emit('changed', { before: beforeByPath, path: _path, action: 'splice', 'arguments': lodash.toArray(arguments), });\n  }\n  \n  /**\n   * Getter from data. Handler can observe changes by current path in data.\n   * @param {string|string[]} path\n   * @param {Cursor~handler} [handler] - Notify you about changes in data by path.\n   * @return data - Returns someting from data by spcefied path.\n   */\n  get(path = null, handler) {\n    this.on(path, handler);\n    return lodash.isNull(path)?this.data:lodash.get(this.data, path);\n  }\n  \n  /**\n   * Handle event changed, as get handler argument, but returns stop method.\n   * @param {string|string[]} path\n   * @param {Cursor~handler} [handler] - Notify you about changes in data by path.\n   * @return {Function} stop\n   */\n  on(path = null, handler) {\n    var eventPath = lodash.toPath(path);\n    if (typeof(handler) == 'function') {\n      var listener = (changes) => {\n        var isClone, beforeValue, afterValue;\n        var eventPathLocal = eventPath.slice(changes.path.length);\n        \n        if (changes.path.length <= eventPath.length) {\n          if (lodash.isEqual(changes.path, eventPath.slice(0, changes.path.length))) {\n            isClone = true;\n            beforeValue = eventPathLocal.length?lodash.get(changes.before, eventPathLocal):changes.before;\n            afterValue = eventPath.length?lodash.get(this.data, eventPath):this.data;\n          } else return;\n        } else {\n          if (lodash.isEqual(eventPath, changes.path.slice(0, eventPath.length))) {\n            isClone = false;\n            beforeValue = afterValue = eventPath.length?lodash.get(this.data, eventPath):this.data;\n          } else return;\n        }\n        \n        handler(beforeValue, afterValue, stop, changes, isClone, this);\n      };\n      var stop = () => this.emitter.removeListener('changed', listener);\n      this.emitter.on('changed', listener);\n      return stop;\n    }\n  }\n}\n\n/**\n * @callback Cursor~handler\n * @param before - Link to this data before the change.\n * @param after - Link to this data after the change.\n * @param {Function} stop\n * @param {Object} changes\n * @param changes.before\n * @param {string[]} changes.path\n * @param {string} changes.action\n * @param {Array} changes.arguments\n * @param {boolean} isClone - True if changed path deeper then event path. For details, read attention.\n * @param {Cursor} cursor\n * @description\n * **Attention!** If the path leads to a higher level of data from the changed, the link to the data `before` the change will lead to the same location as link `after` the change. If the path leads to a changed level or deeper, then `before` and `after` will differ.\n */\n\n/**\n * Queue of bundles execution.\n * You must override _handler, for parse bandles for your cursors.\n */\nexport class BundlesQueue {\n  \n  /**\n   * @constructs BundlesQueue\n   */\n  constructor() {\n    this.nextId = 0;\n    this.handling = false;\n    this.queue = {};\n  }\n  \n  /**\n   * Add received bundles into queue.\n   * @param {number} id\n   * @param task - Any data for your _handler.\n   */\n  addBundle(id, task) {\n    this.queue[id] = task;\n    this.handleNext();\n  }\n  \n  /**\n   * Handle next possible bundle from queue.\n   * Do not do anything if there is no next mandatory bundle in queue.\n   * It is called automatically after each {@link BundlesQueue#addBundle}\n   */\n  handleNext() {\n    /**\n     * @todo May be need protect from call stack, as timeout 0 or some think as...\n     */\n    if (this.handling) return;\n    if (this.queue[this.nextId]) {\n      this.handling = true;\n      this._handler(this.nextId, this.queue[this.nextId], () => {\n        this.handling = false;\n        delete this.queue[this.nextId];\n        this.nextId++;\n        this.handleNext();\n      });\n    }\n  }\n  \n  /**\n   * You must overrided this method, which would somehow handle each bandle.\n   */\n  _handler(id, task, done) {\n    throw new Error('Method _handler must be overrided.');\n  }\n}\n\n/**\n * A small registrar of cursors. Sends into Cursor constructor unique id and link to current manager.\n */\nexport class CursorsManager {\n  constructor(Cursor = Cursor) {\n    this.Cursor = Cursor;\n    this.cursors = {};\n    this.nextId = 0;\n  }\n  \n  /**\n   * Constructs new {@link CursorsManager#Cursor}.\n   * @param query\n   * @param data\n   */\n  new(query, data) {\n    var cursor = new this.Cursor(query, data, this, this.nextId);\n    this.cursors[this.nextId] = cursor;\n    this.nextId++;\n    return cursor;\n  }\n}\n\n/**\n * Attention! If the executers object does not have the correct executer type, an error will be thrown.\n * @param {Object} bundle\n * @param {number} bundle.cursor - id of cursor on current client\n * @param {string} bundle.type - set, unset or splice string\n * @param {Object} executers\n * @param {parseBundle~parser} executers.* - executers for each possible bundle\n * @param {Cursor} cursor\n * @throws Uncaught TypeError: executers[bundle.type] is not a function\n */\nexport function executeBundle(bundle, cursor, executers) {\n  executers[bundle.type](bundle, cursor);\n}\n\n/**\n * @param {Object} bundle\n * @param {string|string[]} bundle.path\n * @param bundle.value\n * @param {Cursor} cursor\n */\nexport function executeBundleSet(bundle, cursor) {\n  cursor.set(bundle.path, bundle.value);\n}\n\n/**\n * @param {Object} bundle\n * @param {string|string[]} bundle.path\n * @param {Cursor} cursor\n */\nexport function executeBundleUnset(bundle, cursor) {\n  cursor.set(bundle.path, undefined);\n}\n\n/**\n * @param {Object} bundle\n * @param {string|string[]} bundle.path\n * @param {number} bundle.start\n * @param {number} bundle.deleteCount\n * @param {Array} bundle.items\n * @param {Cursor} cursor\n */\nexport function executeBundleSplice(bundle, cursor) {\n  cursor.splice(bundle.path, bundle.start, bundle.deleteCount, ...bundle.items);\n}\n\n/**\n * Default executers object.\n */\nexport var executers = {\n  set: executeBundleSet,\n  unset: executeBundleUnset,\n  splice: executeBundleSplice,\n};"]}
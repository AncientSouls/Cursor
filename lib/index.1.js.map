{"version":3,"sources":["../src/lib/index.1.js"],"names":["repl","require","lodash","EventEmitter","Cursor","query","data","manager","id","emitter","path","after","before","cloneDeep","set","emit","start","deleteCount","clone","get","isArray","Error","items","splice","handler","listener","beforeValue","isNull","afterValue","isEqual","stop","removeListener","on","BundlesQueue","nextId","handling","queue","task","handleNext","_handler","done","CursorsManager","cursors","cursor"],"mappings":"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","file":"index.1.js","sourcesContent":["var repl = require('repl');\nvar lodash = require('lodash');\nvar EventEmitter = require('events');\n\n/**\n * One query capsule.\n */\nclass Cursor {\n  \n  /**\n   * @constructs Cursor\n   * @param query - Query resolves current cursor.\n   * @param data - Any data by resolved query.\n   */\n  constructor(query, data, manager, id) {\n    this.query = query;\n    this.data = data;\n    this.manager = manager;\n    this.id = id;\n    this.emitter = new EventEmitter();\n  }\n  \n  /**\n   * Way to change data changes in specified path.\n   * @param {string} path\n   * @param after\n   */\n  set(path, after) {\n    /**\n     * @todo Find better, economically then cloneDeep.\n     */\n    var before = lodash.cloneDeep(this.data);\n    if (!path) this.data = after;\n    else this.data = lodash.set(this.data || {}, path, after);\n    this.emitter.emit('changed', before, this.data);\n  }\n  \n  /**\n   * Way to change array data in specified path. Unlike the standard splice, all arguments are required, except items.\n   * @param {string} path\n   * @param {number} start\n   * @param {number} deleteCount\n   * @param {...*} [items]\n   */\n  splice(path, start, deleteCount, ...items) {\n    var data = lodash.clone(this.get(path));\n    if (!lodash.isArray(data)) throw new Error(`Data by path is not an array.`);\n    data.splice(start, deleteCount, ...items);\n    this.set(path, data);\n  }\n  \n  /**\n   * Getter from data. Handler can observe changes by current path in data.\n   * @param {string} path\n   * @param {Cursor~handler} [handler] - Notify you about changes in data by path.\n   * @return data - Returns someting from data by spcefied path.\n   */\n  get(path = null, handler) {\n    if (typeof(handler) == 'function') {\n      var listener = (before, after) => {\n        var beforeValue = lodash.isNull(path)?before:lodash.get(before, path);\n        var afterValue = lodash.isNull(path)?after:lodash.get(after, path);\n        if (!lodash.isEqual(beforeValue, afterValue)) {\n          handler(beforeValue, afterValue, stop, this);\n        }\n      };\n      var stop = () => this.emitter.removeListener('changed', listener);\n      this.emitter.on('changed', listener);\n    }\n    return lodash.isNull(path)?this.data:lodash.get(this.data, path);\n  }\n}\n\n/**\n * @callback Cursor~handler\n * @param before\n * @param after\n * @param {Function} stop\n * @param {Cursor} cursor\n */\n\nclass BundlesQueue {\n  constructor() {\n    this.nextId = 0;\n    this.handling = false;\n    this.queue = {};\n  }\n  addBundle(id, task) {\n    this.queue[id] = task;\n    this.handleNext();\n  }\n  handleNext() {\n    /**\n     * @todo May be need protect from call stack, as timeout 0 or some think as...\n     */\n    if (this.handling) return;\n    if (this.queue[this.nextId]) {\n      this.handling = true;\n      this._handler(this.nextId, this.queue[this.nextId], () => {\n        this.handling = false;\n        delete this.queue[this.nextId];\n        this.nextId++;\n        this.handleNext();\n      });\n    }\n  }\n  _handler(id, task, done) {\n    throw new Error('Method _handler must be overrided.');\n  }\n}\n\nclass CursorsManager {\n  constructor(Cursor = Cursor) {\n    this.Cursor = Cursor;\n    this.cursors = {};\n    this.nextId = 0;\n  }\n  new(query, data) {\n    var cursor = new this.Cursor(query, data, this, this.nextId);\n    this.cursors[this.nextId] = cursor;\n    this.nextId++;\n    return cursor;\n  }\n}\n\nexport {\n  Cursor,\n  BundlesQueue,\n  CursorsManager,\n};"]}